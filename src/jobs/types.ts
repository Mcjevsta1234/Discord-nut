/**
 * Job Lifecycle Types
 * 
 * Defines the core job model for managing coding request lifecycle.
 * No LLM, Docker, or deployment logic here - just data structures.
 */

import { LLMResponseMetadata } from '../ai/llmMetadata';

export type ProjectType = 'static_html' | 'node_project' | 'discord_bot';

export type JobStatus =
  | 'created'
  | 'planned'
  | 'generated'
  | 'validated'
  | 'packaged'
  | 'deployed'
  | 'done'
  | 'failed';

/**
 * PART C: Pipeline type - determines LLM call strategy
 */
export type PipelineType = '3_stage' | 'direct_cached';

export interface JobInput {
  userMessage: string;
  userId: string;
  guildId?: string;
  channelId: string;
}

export interface JobPaths {
  workspaceDir: string;   // Per-job temp workspace for generated files
  outputDir: string;      // Per-job output folder ready for packaging/deploy
  zipPath?: string;       // Later: path to packaged artifact
  deployDir?: string;     // Later: deployment directory
}

export interface JobPreview {
  enabled: boolean;
  url?: string;
  expiresAt?: number;
}

interface TokenUsageRecord {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  cost: number;
  model: string;
}

export interface JobDiagnostics {
  logsPath: string;                         // Per-job log file path
  stageTimings: Record<string, number>;     // Milliseconds per stage
  pipeline?: PipelineType;                  // PART C: Which pipeline was used
  cachingCapable?: boolean;                 // PART C: Was caching available
  tokenUsage: {
    total: number;
    promptImprover?: TokenUsageRecord;
    planner?: TokenUsageRecord;
    generator?: TokenUsageRecord;
  };
  llmMetadata?: {
    promptImprover?: LLMResponseMetadata;
    planner?: LLMResponseMetadata;
    generator?: LLMResponseMetadata;
  };
  specMetrics?: {
    wordCount: number;
    bulletCount: number;
    sectionsFound: string[];
  };
  policyFlags?: {
    prompterHasAppendix: boolean;
    plannerAppendedAppendix: boolean;
    codeAppendedAppendix: boolean;
  };
}

export interface ImprovedSpec {
  title: string;
  projectType: ProjectType;
  spec: string;
  output: {
    format: 'single_file' | 'multi_file';
    primaryFile: string;
    notes?: string;
  };
  acceptanceChecklist: string[];
}

export interface PlanStep {
  id: string;
  name: string;
  goal: string;
  inputs: string[];
  outputs: string[];
  risk: 'low' | 'medium' | 'high';
  validation: string[];
}

export interface FilePlanEntry {
  path: string;
  purpose: string;
  notes: string;
}

export interface AcceptanceMapping {
  checklistItem: string;
  coveredBySteps: string[];
}

export interface Plan {
  title: string;
  projectType: ProjectType;
  buildStrategy: 'none' | 'static' | 'node';
  filePlan: FilePlanEntry[];
  steps: PlanStep[];
  acceptanceMapping: AcceptanceMapping[];
  guardrails: {
    noExternalAssets: boolean;
    singleShotUserFlow: boolean;
    noUserIteration: boolean;
    doNotAddFeaturesNotInSpec: boolean;
  };
}

export interface GeneratedFile {
  path: string;
  content: string;
}

export interface CodegenResult {
  files: GeneratedFile[];
  entrypoints: {
    run?: string;
    dev?: string;
    build?: string;
  };
  notes: string;
}

export interface Job {
  jobId: string;                    // Unique, URL-safe identifier
  createdAt: string;                // ISO timestamp
  projectType: ProjectType;
  status: JobStatus;
  input: JobInput;
  paths: JobPaths;
  preview: JobPreview;
  diagnostics: JobDiagnostics;
  spec?: ImprovedSpec;              // Generated by prompt improver
  plan?: Plan;                      // Generated by planner
  codegenResult?: CodegenResult;    // Generated by code generator
  zipPath?: string;                 // Path to zip archive of all generated files
}
